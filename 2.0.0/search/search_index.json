{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Auto Dagger","text":"<p>Auto Dagger allows you to automate some Dagger setup using Hilt.</p> <p>For example you can use the <code>@AutoInitialize</code> annotation to automatically initialize objects during app launch and you can use the <code>@AutoBind</code> annotation to automatically bind objects.</p> <p>Automatic initialization is done using AndroidX Startup.</p> <p>There's also integrations with popular third party libraries such as AndroidX and Retrofit.  </p> <p>You can find the project on GitHub in the ansman/auto-dagger repo.</p> <p>If you're looking javadoc/dokka you can find it here here.</p> <p>To get set up see getting started.</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#autobind","title":"<code>@AutoBind</code>","text":"<pre><code>interface Repository\n@AutoBind\n@Singleton\nclass RealRepository @Inject constructor() : Repository\n</code></pre> <p>For more detailed documentation see the <code>@AutoBind</code> usage.</p>"},{"location":"#autoinitialize","title":"<code>@AutoInitialize</code>","text":"<pre><code>@AutoInitialize\n@Singleton\nclass SomeRepository @Inject constructor() {\ninit {\n// This will be executed at application startup, even if nobody injects it.\n}\n}\n</code></pre> <p>For more detailed documentation see the <code>@AutoInitialize</code> usage.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#android-modules","title":"Android Modules","text":"<p>For pure Kotlin modules you need to add KSP, the auto-dagger android dependency, the  auto-dagger compiler as well as the hilt dependencies: <pre><code>plugins {\nid(\"com.google.devtools.ksp\")\nid(\"com.google.dagger.hilt.android\") // Optional, but recommended\n}\ndependencies {\n// For app modules add the android dependency\nimplementation(\"se.ansman.dagger.auto:android:2.0.0\")\n// And for library modules add the android-api dependency:\nimplementation(\"se.ansman.dagger.auto:android-api:2.0.0\")\n// Next add the compiler using KSP\nksp(\"se.ansman.dagger.auto:compiler:2.0.0\")\n// Add these if you want to replace objects during tests\ntestImplementation(\"se.ansman.dagger.auto:android-testing:2.0.0\")\nkspTest(\"se.ansman.dagger.auto:compiler:2.0.0\")\n// If you haven't already, you need to add the Dagger dependencies\nimplementation(\"com.google.dagger:hilt-android:2.56.2\")\nksp(\"se.ansman.dagger.auto:compiler:2.0.0\")\n}\n</code></pre></p>"},{"location":"getting-started/#kotlin-modules","title":"Kotlin Modules","text":"<p>For pure Kotlin modules you need to add KSP, the auto-dagger core dependency, the auto-dagger compiler as well as the hilt dependencies: <pre><code>plugins {\nid(\"com.google.devtools.ksp\")\n}\ndependencies {\nimplementation(\"se.ansman.dagger.auto:core:2.0.0\")\nksp(\"se.ansman.dagger.auto:compiler:2.0.0\")\n// If you haven't already you need to add the Dagger dependencies\nimplementation(\"com.google.dagger:hilt-core:2.56.2\")\nksp(\"com.google.dagger:hilt-compiler:2.56.2\")\n}\n</code></pre></p>"},{"location":"getting-started/#snapshots","title":"Snapshots","text":"<p>Snapshots are published on every commit to Sonatype's snapshot repository.  To use a snapshot add the snapshot repository: <pre><code>buildscripts {\nrepositories {\n...\nmaven(\"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n}\n}\ndependencies {\nimplementation(\"se.ansman.dagger.auto:android:2.1.0-SNAPSHOT\")\nksp(\"se.ansman.dagger.auto:compiler:2.1.0-SNAPSHOT\")\n}\n</code></pre></p>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#autoinitializable-objects-must-be-singleton-scoped","title":"<code>@AutoInitializable</code> objects must be <code>@Singleton</code> scoped","text":"<p>For now, all initializable objects must be <code>@Singleton</code> scoped.</p> <p>This is because the semantics are unclear if an objects are not scoped since <code>AutoDaggerInitializable</code> is not scoped so  creating multiple instances of <code>AutoDaggerInitializable</code> would created multiple instances of unscoped objects which might be unexpected.</p> <p>This limitation might be lifted in the future. If you have a use case for unscoped objects please  file an issue.</p>"},{"location":"limitations/#autobind-objects-must-not-be-generic","title":"<code>@AutoBind</code> objects must not be generic","text":"<p>Since Auto Dagger cannot determine actual type arguments, generic objects cannot be automatically bound.</p>"},{"location":"limitations/#autobind-only-supports-direct-supertypes","title":"<code>@AutoBind</code> only supports direct supertypes","text":"<p>You can only bind objects to their direct supertypes. For example this isn't supported: <pre><code>interface Closeable\ninterface Repository : Closeable\n// This won't work because `RealRepository` doesn't \n// directly implement `Closeable`\n@AutoBindIntoSet(asTypes = [Closeable::class])\n@Singleton\nclass RealRepository @Inject constructor() : Repository\n</code></pre></p> <p>To solve this just add an explicit supertype: <pre><code>@AutoBindIntoSet(asTypes = [Closeable::class])\n@Singleton\nclass RealRepository @Inject constructor() : Repository, Closeable\n</code></pre></p>"},{"location":"about/how-it-works/","title":"How it works","text":""},{"location":"about/how-it-works/#autobind","title":"<code>@AutoBind</code>","text":"<p>When you annotate an object with <code>@AutoBind</code>, Auto Dagger will generate a component which is installed into the inferred (or explicitly provided) component using Hilt.</p> <p>Given this class: <pre><code>interface Repository\n@AutoBind\n@Singleton\nclass RealRepository @Inject constructor() : Repository\n</code></pre></p> <p>Auto Dagger will generate this module: <pre><code>@Module\n@InstallIn(SingletonComponent.class)\n@OriginatingElement(topLevelClass = RealRepository.class)\npublic abstract class AutoBindRealRepositorySingletonModule {\nprivate AutoBindRealRepositorySingletonModule() {}\n@Binds\npublic abstract Repository bindRealRepositoryAsRepository(RealRepository realRepository);\n}\n</code></pre></p>"},{"location":"about/how-it-works/#autoinitialize","title":"<code>@AutoInitialize</code>","text":"<p>When you annotate an object, binding or provider with <code>@AutoInitialize</code>, Auto Dagger will generate a module which is installed into the <code>SingletonComponent</code> using Hilt.</p> <p>Given this class: <pre><code>@AutoInitialize\n@Singleton\nclass Repository @Inject constructor()\n</code></pre></p> <p>Auto Dagger will generate this module: <pre><code>@Module\n@InstallIn(SingletonComponent.class)\n@OriginatingElement(topLevelClass = Repository.class)\npublic final class AutoInitializeRepositoryModule {\nprivate AutoInitializeRepositoryModule() {}\n@Provides\n@IntoSet\npublic static Initializable provideRepositoryAsInitializable(Lazy&lt;Repository&gt; lazyRepository) {\nreturn Initializable.fromLazy(lazyRepository);\n}\n}\n</code></pre></p>"},{"location":"about/how-it-works/#autodaggerinitializable","title":"<code>AutoDaggerInitializable</code>","text":"<p><code>AutoDaggerInitializable</code> is the container for all <code>Initializable</code> that should be initialized at startup. It's provided into the <code>@Singleton</code> component, and accepts a set of all the initializables.</p> <p>Calling <code>AutoDaggerInitializable.initialize</code> calls <code>initialize</code> on each object in turn.</p> <p>Any exceptions are rethrown, but only after all objects have been initialized. If multiple objects throw, then  subsequent exceptions are added as suppressed exceptions.</p>"},{"location":"about/how-it-works/#autodaggerstartupinitializer","title":"<code>AutoDaggerStartupInitializer</code>","text":"<p><code>AutoDaggerStartupInitializer</code> is the AndroidX Startup initializer that performs the initialization at startup.</p>"},{"location":"about/license/","title":"License","text":"<pre><code>Copyright 2022-2023 Nicklas Ansman Giertz\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <p>You can find the full license at ansman/auto-dagger.</p>"},{"location":"integrations/ktorfit/","title":"Integration with Ktorfit","text":"<p>If you use Ktorfit to define your API services, you can use the  <code>@AutoProvideService</code> to automatically contribute your services to the Dagger graph.</p> <p>Firstly add the required dependency: <pre><code>dependencies {\nimplementation(\"se.ansman.dagger.auto:ktorfit:2.0.0\")\nksp(\"se.ansman.dagger.auto:compiler:2.0.0\")\n}\n</code></pre></p> <p>Then annotate your service with <code>@AutoProvideService</code>: <pre><code>@AutoProvideService\nclass ApiService {\n@GET(\"users\")\nsuspend fun getUsers(): List&lt;User&gt;\n}\n</code></pre></p> <p>You'll also need to provide a Ktorfit instance to the component you want to inject the service into: <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject KtorfitModule {\n@Provides\n@Singleton\nfun provideKtorfit(): Ktorfit = Ktorfit.Builder()\n// Perform any setup you need\n.baseUrl(\"https://api.example.com/\")\n.build()\n}\n</code></pre></p>"},{"location":"integrations/ktorfit/#changing-the-target-component","title":"Changing the target component","text":"<p>By default, services are installed in the <code>SingletonComponent</code>. If you'd like to change this you can do so by specifying the <code>inComponent</code> parameter: <pre><code>@AutoProvideService(inComponent = SomeOtherComponent::class)\nclass ApiService {\n// Service methods\n}\n</code></pre></p>"},{"location":"integrations/ktorfit/#qualifiers","title":"Qualifiers","text":"<p>If you have multiple ktorfit instances and use qualifiers to differentiate them, you can specify the qualifier on the service: <pre><code>@AutoProvideService\n@Named(\"api1\")\nclass ApiService {\n// Service methods\n}\n</code></pre></p>"},{"location":"integrations/ktorfit/#making-the-service-scoped-or-reusable","title":"Making the service scoped or reusable","text":"<p>If you'd like to cache/reuse the service instances you can annotate the service with a scope or <code>@Reusable</code>: <pre><code>@Singleton // This must match the `inComponent` parameter of @AutoProvideService\n@AutoProvideService\nclass ApiService {\n// Service methods\n}\n// Or if you want to make it reusable\n@Reusable\n@AutoProvideService\nclass ApiService {\n// Service methods\n}\n</code></pre></p>"},{"location":"integrations/retrofit/","title":"Integration with Retrofit","text":"<p>If you use Retrofit to define your API services, you can use the  <code>@AutoProvideService</code> to automatically contribute your services to the Dagger graph.</p> <p>Firstly add the required dependency: <pre><code>dependencies {\nimplementation(\"se.ansman.dagger.auto:retrofit:2.0.0\")\nksp(\"se.ansman.dagger.auto:compiler:2.0.0\")\n}\n</code></pre></p> <p>Then annotate your service with <code>@AutoProvideService</code>: <pre><code>@AutoProvideService\nclass ApiService {\n@GET(\"users\")\nsuspend fun getUsers(): List&lt;User&gt;\n}\n</code></pre></p> <p>You'll also need to provide a Retrofit instance to the component you want to inject the service into: <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject RetrofitModule {\n@Provides\n@Singleton\nfun provideRetrofit(): Retrofit = Retrofit.Builder()\n// Perform any setup you need\n.baseUrl(\"https://api.example.com/\")\n.addConverterFactory(SomeConverterFactory.create())\n.build()\n}\n</code></pre></p>"},{"location":"integrations/retrofit/#changing-the-target-component","title":"Changing the target component","text":"<p>By default, services are installed in the <code>SingletonComponent</code>. If you'd like to change this you can do so by specifying the <code>inComponent</code> parameter: <pre><code>@AutoProvideService(inComponent = SomeOtherComponent::class)\nclass ApiService {\n// Service methods\n}\n</code></pre></p>"},{"location":"integrations/retrofit/#qualifiers","title":"Qualifiers","text":"<p>If you have multiple retrofit instances and use qualifiers to differentiate them, you can specify the qualifier on the service: <pre><code>@AutoProvideService\n@Named(\"api1\")\nclass ApiService {\n// Service methods\n}\n</code></pre></p>"},{"location":"integrations/retrofit/#making-the-service-scoped-or-reusable","title":"Making the service scoped or reusable","text":"<p>By default, provided service is unscoped and will be created every time it is injected. Retrofit caches the parsing of services so this is not an expensive operation, but it injected frequently you can avoid this by annotating your service with a scope or <code>@Reusable</code>: <pre><code>@Singleton // This must match the `inComponent` parameter of @AutoProvideService\n@AutoProvideService\nclass ApiService {\n// Service methods\n}\n// Or if you want to make it reusable\n@Reusable\n@AutoProvideService\nclass ApiService {\n// Service methods\n}\n</code></pre></p>"},{"location":"integrations/androidx/room/","title":"Integration with AndroidX Room","text":"<p>If you use AndroidX Room in your project, Auto Dagger can automatically provides some utilities for working with databases.</p> <p>To get started, add the dependency: <pre><code>dependencies {\nimplementation(\"se.ansman.dagger.auto:androidx-room:2.0.0\")\nksp(\"se.ansman.dagger.auto:compiler:2.0.0\")\n}\n</code></pre></p>"},{"location":"integrations/androidx/room/#automatically-providing-daos","title":"Automatically providing DAOs","text":"<p>You can annotate your <code>RoomDatabase</code> with <code>@AutoProvideDaos</code> to automatically provide all DAOs in the database: <pre><code>@Database(entities = [User::class], version = 1)\n@AutoProvideDaos\nabstract class AppDatabase : RoomDatabase() {\nabstract val users: UserDao\n}\n</code></pre></p> <p>Now you can inject <code>UserDao</code> directly.</p> <p>By default, the DAOs will be provided in the <code>SingletonComponent</code>. If you want to change the component you can use the <code>inComponent</code> parameter: <pre><code>@Database(entities = [User::class], version = 1)\n@AutoProvideDaos(inComponent = SomeOtherComponent::class)\nabstract class AppDatabase : RoomDatabase() {\nabstract val users: UserDao\n}\n</code></pre></p> <p>For now, the database must directly extend <code>RoomDatabase</code>. Having it as an indirect superclass is not supported. If you need support for this open a feature request and detail your use case.</p>"},{"location":"integrations/androidx/viewmodel/","title":"Integration with AndroidX ViewModel","text":"<p>If you use AndroidX ViewModel in your project, Auto Dagger can automatically provides some utilities for working with view models.</p> <p>To get started, add the dependency: <pre><code>dependencies {\nimplementation(\"se.ansman.dagger.auto:androidx-viewmodel:2.0.0\")\n}\n</code></pre></p>"},{"location":"integrations/androidx/viewmodel/#coroutinescope","title":"CoroutineScope","text":"<p>If you use Kotlin Coroutines, you can inject a <code>CoroutineScope</code> into your view models. This allows you to use a test scope when testing your view models.</p> <p>The scope has the <code>ViewModelSpecific</code> qualifier and uses a <code>SupervisorJob</code> and the <code>Dispatchers.Main.immediate</code>  dispatcher.</p> <p>Usage: <pre><code>@HiltViewModel\nclass MyViewModel @Inject constructor(\n@ViewModelSpecific\nprivate val viewModelScope: CoroutineScope\n) : ViewModel()\n</code></pre></p>"},{"location":"integrations/androidx/viewmodel/#viewmodelspecific","title":"ViewModelSpecific","text":"<p><code>ViewModelSpecific</code> is a qualifier annotation that can be used to inject objects that are specific to a view model, but might otherwise be added to your graph such as <code>CoroutineScope</code>.</p>"},{"location":"usage/auto-bind/","title":"<code>@AutoBind</code> Usage","text":"<p>To bind objects automatically you just need to annotate a class with the <code>@AutoBind</code> annotation (or <code>@AutoBindIntoSet</code> for binding into a set and <code>@AutoBindIntoMap</code> for binding into a map).</p> <pre><code>interface Repository\n@AutoBind\n@Singleton\nclass RealRepository @Inject constructor() : Repository\n// Generates the equivalent to:\n@Binds\nabstract fun RealRepository.bindRealRepositoryAsRepository(): Repository\n</code></pre>"},{"location":"usage/auto-bind/#multibindings","title":"Multibindings","text":"<p>If you need to bind a object into a set or map you can use <code>@AutoBindIntoSet</code> or <code>@AutoBindIntoMap</code> respectively.</p> <pre><code>// Binds ExternalResource as Closeable using @IntoSet\n@AutoBindIntoSet\n// Binds ExternalResource as Closeable using @IntoMap with\n// `StringKey` as the map key\n@AutoBindIntoMap\n@StringKey(\"ExternalResourceCloseable\")\n@Singleton\nclass ExternalResource @Inject constructor() : Closeable {\noverride fun close() {}\n}\n// Generates the equivalent to:\n@Binds\n@IntoSet\nabstract fun ExternalResource.bindExternalResourceAsCloseableIntoSet(): Closeable\n@Binds\n@IntoMap\n@StringKey(\"ExternalResourceCloseable\")\nabstract fun ExternalResource.bindExternalResourceAsCloseableIntoMap(): Closeable\n</code></pre>"},{"location":"usage/auto-bind/#component","title":"Component","text":"<p>AutoDagger will try to infer the component to install the binding in using the scope. The following mapping is used:</p> Scope Component No scope <code>SingletonComponent</code> <code>Singleton</code> <code>SingletonComponent</code> <code>Reusable</code> <code>SingletonComponent</code> <code>ActivityRetainedScoped</code> <code>ActivityRetainedComponent</code> <code>ActivityScoped</code> <code>ActivityComponent</code> <code>FragmentScoped</code> <code>FragmentComponent</code> <code>ServiceScoped</code> <code>ServiceComponent</code> <code>ViewScoped</code> <code>ViewComponent</code> <code>ViewModelScoped</code> <code>ViewModelComponent</code> <code>ViewWithFragmentScoped</code> <code>ViewWithFragmentComponent</code> <p>If you are are using custom scopes or want to change which component the binding is installed in, you can use the  <code>inComponent</code> property: <pre><code>@AutoBind(inComponent = SomeComponent::class)\nclass ExternalResource @Inject constructor() : Closeable {\noverride fun close() {}\n}\n</code></pre></p>"},{"location":"usage/auto-bind/#binding-multiple-types","title":"Binding multiple types","text":"<p>If your object has multiple direct supertypes, you need to specify which ones to bind explicitly using the <code>asTypes</code> parameter: <pre><code>@AutoBind(asTypes = [Closeable::class])\nclass ExternalResource @Inject constructor() : Runnable, Closeable {\noverride fun run() {}\noverride fun close() {}\n}\n</code></pre></p> <p>You can bind multiple types, but only direct supertypes can be bound (see limitations).</p>"},{"location":"usage/auto-bind/#objects","title":"Objects","text":"<p>Normally the bound object needs to be provided to the dependency graph using either an <code>@Provides</code> annotated method or using an <code>@Inject</code> annotated constructor.</p> <p>Auto Dagger allows you to annotate a Kotlin object with <code>@AutoBind</code> without it being provided in the graph. This is especially useful for tests: <pre><code>@AutoBind\nobject DirectExecutor : Executor {\noverride fun execute(command: Runnable) {\ncommand.run()\n}\n}\n</code></pre></p>"},{"location":"usage/auto-bind/#generics","title":"Generics","text":"<p>When using multibindings, it's often useful to be able to bind generic types as wildcard.</p> <p>Auto Dagger will, by default, bind the exact type of the supertype. But using the <code>bindGenericAs</code> parameter you can chose to bind it as a wildcard instead.</p> <p>For types you own, it's sometimes useful to specify a different default for <code>bindGenericAs</code>. For example, say you have a <code>Resource&lt;T&gt;</code> interface. You probably want to always bind this using wildcards since every resource will have a unique type for <code>T</code>. So you can annotate <code>Resource</code> with <code>@BindGenericAs.Default(BindGenericAs.Wildcard)</code> to indicate  that, unless specified explicitly, it should be bound as <code>Resource&lt;*&gt;</code>. </p> <pre><code>// This will bind StringCallable as Callable&lt;*&gt;\n@AutoBindIntoSet(bindGenericAs = BindGenericAs.Wildcard)\nclass StringCallable @Inject constructor() : Callable&lt;String&gt; {\noverride fun call(): String = \"\"\n}\n// For types you own you can specify @BindGenericAs.Default to change the default.\n@BindGenericAs.Default(BindGenericAs.Wildcard)\ninterface Resource&lt;T&gt;\n// This will be bound as Resource&lt;*&gt; since the default has been set to wildcard for Resource.\n@AutoBindIntoSet\nclass SomeResource @Inject constructor() : Resource&lt;Something&gt;\n</code></pre> <p>There are 3 options for <code>bindGenericAs</code>:</p> <ul> <li><code>Type</code> - Binds the object to the exact supertype (<code>Callable&lt;String&gt;</code> in the example above). This is the default unless set with <code>@BindGenericAs.Default</code>. </li> <li><code>Wildcard</code> - Binds the object using wildcards (<code>Callable&lt;*&gt;</code> in the example above).</li> <li><code>TypeAndWildcard</code> - Binds the object as both the exact type and using wildcards.</li> </ul>"},{"location":"usage/auto-initialize/","title":"<code>@AutoInitialize</code> Usage","text":"<p>Simply annotate any <code>@Singleton</code> scoped object, provider or binding with <code>@AutoInitialize</code> to make it be automatically  initialized when your application launches.</p> <pre><code>@AutoInitialize\n@Singleton\nclass SomeRepository @Inject constructor() {\ninit {\n// This will be executed at application startup, even if nobody injects it.\n}\n}\n</code></pre>"},{"location":"usage/auto-initialize/#initializable","title":"Initializable","text":"<p>It's often considered bad practice to have side effects in a constructor/initializer block. If this is a concern, your object can implement the <code>Initializable</code> interface. Auto Dagger will then call <code>initialize</code> when it's time to initialize.</p> <pre><code>@AutoInitialize\n@Singleton\nclass SomeRepository @Inject constructor() : Initializable {\noverride fun initialize() {\n// This will be executed at application startup, even if nobody injects it.\n}\n}\n</code></pre>"},{"location":"usage/auto-initialize/#priority","title":"Priority","text":"<p>By default objects are initialized in an undefined order. This can be changed by setting a priority.</p> <p>Objects are initialized in descending priority with the default priority being <code>1</code>. Setting the priority to 0 or below makes the object be initialized after objects with the default priority and setting the priority to 2 or above  initializes it before.</p> <pre><code>@AutoInitialize(priority = 4711)\n@Singleton\nclass ImportantRepository @Inject constructor() {\noverride fun initialize() {\n// This will be called earlier than objects without a priority\n}\n}\n</code></pre>"},{"location":"usage/auto-initialize/#androidx-startup","title":"AndroidX Startup","text":"<p>Auto Dagger uses AndroidX Startup to initialize objects  at startup.</p> <p>If you prefer to not use this you can just depend on the <code>core</code> artifact which won't pull in AndroidX Startup.</p> <p>To initialize the objects manually, use <code>AutoDaggerInitializer</code>.</p> <p><pre><code>@HiltAndroidApp\nclass TheApp : Application() {\n@Inject\nlateinit var initializer: AutoDaggerInitializer\noverride fun onCreate() {\nsuper.onCreate()\ninitializer.initialize()\n}\n}\n</code></pre> You'll also want to disable the androidx startup initializer by adding this to your app's manifest: <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"&gt;\n&lt;application&gt;\n&lt;provider\nandroid:name=\"androidx.startup.InitializationProvider\"\nandroid:authorities=\"${applicationId}.androidx-startup\"\nandroid:exported=\"false\"\ntools:node=\"merge\"&gt;\n&lt;meta-data\nandroid:name=\"se.ansman.dagger.auto.android.AutoDaggerStartupInitializer\"\nandroid:value=\"androidx.startup\"\ntools:node=\"remove\" /&gt;\n&lt;/provider&gt;\n&lt;/application&gt;\n&lt;/manifest\n</code></pre></p>"},{"location":"usage/optionally-provided/","title":"<code>@OptionallyProvided</code> Usage","text":"<p>Denotes that the annotated type might not be provided to the dependency graph.</p> <p>This will generate a <code>@BindsOptionalOf</code> binding for the annotated type.</p> <p>This is useful when the type will only be provided under certain circumstances. For example an Android app might have some debug settings that are only available in debuggable builds.</p> <pre><code>@OptionallyProvided\ninterface DebugApi\n// This generates\n@BindsOptionalOf\nabstract fun bindsOptionalDebugApi(): DebugApi\n// Then in your implementation module\n@AutoBind\n@Singleton\nclass RealDebugApi @Inject constructor() : DebugApi\n</code></pre>"},{"location":"usage/optionally-provided/#component","title":"Component","text":"<p>AutoDagger will try to infer the component to install the binding in using the scope. The following mapping is used:</p> Scope Component No scope <code>SingletonComponent</code> <code>Singleton</code> <code>SingletonComponent</code> <code>Reusable</code> <code>SingletonComponent</code> <code>ActivityRetainedScoped</code> <code>ActivityRetainedComponent</code> <code>ActivityScoped</code> <code>ActivityComponent</code> <code>FragmentScoped</code> <code>FragmentComponent</code> <code>ServiceScoped</code> <code>ServiceComponent</code> <code>ViewScoped</code> <code>ViewComponent</code> <code>ViewModelScoped</code> <code>ViewModelComponent</code> <code>ViewWithFragmentScoped</code> <code>ViewWithFragmentComponent</code> <p>If you are are using custom scopes or want to change which component the binding is installed in, you can use the <code>inComponent</code> property: <pre><code>@OptionallyProvided(inComponent = SomeComponent::class)\ninterface DebugApi\n</code></pre></p>"},{"location":"usage/optionally-provided/#qualifiers","title":"Qualifiers","text":"<p>Any <code>Qualifier</code>s on the annotated type will be carried over to the binding: <pre><code>@Named(\"Prod\")\n@OptionallyProvided\ninterface Authenticator\n\n// Generates the equivalent to:\n@BindsOptionalOf\n@Named(\"Prod\")\nabstract fun bindsOptionalAuthenticator(): Authenticator\n</code></pre></p>"},{"location":"usage/replaces/","title":"<code>@Replaces</code> Usage","text":"<p>During tests it's often useful to swap out real dependencies for fake dependencies. If you're using <code>@AutoBind</code> to bind your dependencies then it's trivial to swap out dependencies during tests using the <code>@Replaces</code> annotation: <pre><code>interface Repository\n@AutoBind\n@Singleton\nclass RealRepository @Inject constructor() : Repository\n// In your test source set\n@Replaces(RealRepository::class)\n@Singleton\nclass FakeRepository @Inject constructor() : Repository\n</code></pre></p> <p>To use <code>@Replaces</code> there are some requirements:</p> <ul> <li>The replacement must implement the types bound the target. </li> <li>The replacement target must be annotated with <code>@AutoBind</code>.</li> <li>The replacement must not be annotated with <code>@AutoBind</code>, <code>@AutoBindIntoSet</code>, <code>@AutoBindIntoMap</code>, or <code>@AutoInitialize</code>.</li> </ul>"},{"location":"usage/replaces/#multibindings","title":"Multibindings","text":"<p>If the replaced type uses multibindings (<code>@AutoBindIntoSet</code> or <code>@AutoBindIntoMap</code>) then those are only replaced if the annotated type also implements them. Otherwise the multibinding is removed.</p> <p>So for example. If the target type uses <code>@AutoBindIntoSet</code> to bind it as a <code>Closeable</code> but your replacement doesn't  implement <code>Closeable</code> then that binding is removed. If it does implement <code>Closeable</code> then the binding is replaced with the fake binding.</p>"},{"location":"usage/replaces/#auto-initialize","title":"Auto Initialize","text":"<p>If the target type is annotated with <code>@AutoInitialize</code>, then an empty module will be generated to replace the auto initialize module, effectively removing it.</p>"},{"location":"usage/replaces/#objects","title":"Objects","text":"<p>Normally the replacement object needs to be provided to the dependency graph using either an <code>@Provides</code> annotated method or using an <code>@Inject</code> annotated constructor.</p> <p>Auto Dagger allows you to annotate a Kotlin object with <code>@Replaces</code> without it being provided in the graph. This is especially useful for tests: <pre><code>@Replaces(ThreadPoolExecutor::class)\nobject DirectExecutor : Executor {\noverride fun execute(command: Runnable) {\ncommand.run()\n}\n}\n</code></pre></p>"}]}